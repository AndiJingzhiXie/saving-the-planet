class Organism {
    constructor(name, count, huntingProb, lowFoodLimit, currentFoodCount, foodUsage, matingProb, foodSource, foodAvailable) {
        this.name = name;
        this.count = count;
        this.huntingProb = huntingProb;
        this.lowFoodLimit = lowFoodLimit;
        this.currentFoodCount = currentFoodCount;
        this.foodUsage = foodUsage;
        this.matingProb = matingProb;
        this.foodSource = foodSource; // this would be an array of other Organism names it can hunt.
        this.foodAvailable = foodAvailable;
    }

    hunt(ecosystem) {
        if (this.currentFoodCount < this.lowFoodLimit) {
            for (let prey of this.foodSource) {
                let preyOrg = ecosystem.find(org => org.name === prey);
                if (preyOrg && Math.random() < this.huntingProb) {
                    // Successful hunt
                    this.currentFoodCount += preyOrg.foodAvailable;
                    preyOrg.count -= 1;
                }
            }
        }
    }

    reproduce() {
        if (Math.random() < this.matingProb) {
            this.count += 1;
        }
    }

    consumeFood() {
        this.currentFoodCount -= this.foodUsage;
        if (this.currentFoodCount <= 0) {
            this.count -= 1;
            this.currentFoodCount = 0;
        }
    }

    dailyRoutine(ecosystem) {
        this.hunt(ecosystem);
        this.reproduce();
        this.consumeFood();
        this.count = Math.max(0, this.count);
				if (this.currentFoodCount <= 0) {
      		  this.count--;
       		 this.currentFoodCount = 0;  // reset to zero if it goes negative
  		  }
    }
}

let rabbit = new Organism('Rabbit', 50, 0.7, 10, 20, 2, 0.5, ['Grass'], 5);
let fox = new Organism('Fox', 10, 0.5, 8, 15, 4, 0.4, ['Rabbit'], 7);
let grass = new Organism('Grass', 1000, 0, 0, 1000, 0, 0.8, [], 1);

let ecosystem = [rabbit, fox, grass];

function simulateDay(ecosystem) {
    ecosystem.forEach(org => org.dailyRoutine(ecosystem));
}

function checkFoodChainBroken(ecosystem) {
    for (let organism of ecosystem) {
        if (organism.count <= 0) {
            for (let otherOrganism of ecosystem) {
                if (otherOrganism.foodSource.includes(organism.name)) {
                    return true; // food chain is broken
                }
            }
        }
    }
    return false;
}

function updateUI() {
    ecosystem.forEach(org => {
        document.getElementById(`${org.name}-count`).textContent = org.count;
    });
}


let dayCount = 0;
let history = {
    Rabbit: [],
    Fox: [],
    Grass: []
};

// ...[pre-existing code]

let chart;

function initializeGraph() {
    var ctx = document.getElementById('populationChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [], 
            datasets: [{
                label: 'Rabbit',
                data: [],
                borderColor: 'blue',
                fill: false
            }, {
                label: 'Fox',
                data: [],
                borderColor: 'red',
                fill: false
            }, {
                label: 'Grass',
                data: [],
                borderColor: 'green',
                fill: false
            }]
        },
        options: {
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Days'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Population'
                    }
                }
            }
        }
    });
}

function updateGraph() {
    chart.data.labels.push(dayCount);
    chart.data.datasets[0].data.push(history.Rabbit[dayCount - 1]);
    chart.data.datasets[1].data.push(history.Fox[dayCount - 1]);
    chart.data.datasets[2].data.push(history.Grass[dayCount - 1]);
    chart.update();
}

function runSimulationDayByDay() {
    if(!checkFoodChainBroken(ecosystem)) {
        simulateDay(ecosystem);

        // Halt the simulation if any organism count is non-positive
        if(ecosystem.some(org => org.count <= 0)) {
            alert(`The food chain is broken on day ${dayCount} due to a negative or zero count!`);
            return;
        }
        simulateDay(ecosystem);
        dayCount++;

        // Add to history
        ecosystem.forEach(org => {
            history[org.name].push(org.count);
        });

        updateUI();
        updateGraph();

        // Simulate next day after 1 second (1000ms)
        setTimeout(runSimulationDayByDay, 1000);
    } else {
        alert(`The food chain is broken on day ${dayCount}!`);
    }
}

// ...[rest of the code]

// Initialize the graph and start the simulation
initializeGraph();
runSimulationDayByDay();
